# --- Do not remove these libs ---
from freqtrade.strategy import IStrategy, merge_informative_pair, DecimalParameter, IntParameter, CategoricalParameter
import pandas as DataFrame
import talib.abstract as ta
import freqtrade.vendor.qtpylib.indicators as qtpylib

# --------------------------------
import pandas as pd
import numpy as np
import technical.indicators as ftt
from freqtrade.exchange import timeframe_to_minutes
from datetime import datetime
from typing import Optional, Tuple, Union
from dataclasses import dataclass
from freqtrade.persistence import Trade, Order
from datetime import datetime, timezone, timedelta
import logging
logger = logging.getLogger(__name__)
        
def ssl_atr(dataframe, length=7):
    df = dataframe.copy()
    df['smaHigh'] = df['high'].rolling(length).mean() + df['atr']
    df['smaLow'] = df['low'].rolling(length).mean() - df['atr']
    df['hlv'] = np.where(df['close'] > df['smaHigh'], 1, np.where(df['close'] < df['smaLow'], -1, np.NAN))
    df['hlv'] = df['hlv'].ffill()
    df['sslDown'] = np.where(df['hlv'] < 0, df['smaHigh'], df['smaLow'])
    df['sslUp'] = np.where(df['hlv'] < 0, df['smaLow'], df['smaHigh'])
    return df['sslDown'], df['sslUp']


class SampleStrategy(IStrategy):
        
    # Condition for short trade
    can_short = True

    # Enable the position adjustment
    position_adjustment_enable = True
    max_adjustments = 3
    # Example specific variables
    max_entry_position_adjustment = 5

    # Optimal timeframe for the strategy
    timeframe = '5m'

    # generate signals from the 1h timeframe
    informative_timeframe = '1h'

    # WARNING: ichimoku is a long indicator, if you remove or use a
    # shorter startup_candle_count your backtest results will be unreliable
    startup_candle_count = 500

    # NOTE: this strat only uses candle information, so processing between
    # new candles is a waste of resources as nothing will change
    process_only_new_candles = True

    # ROI table:
    timeframe_mins = timeframe_to_minutes(timeframe)

    # Trailing stoploss parameters
    trailing_stop = True  # Disable the default trailing stoploss
    trailing_stop_positive = 0.01  # Activate trailing stop when profit reaches 1%
    trailing_stop_positive_offset = 0.035  # Activate trailing stop at 3.5% above the initial entry price
    trailing_only_offset_is_reached = True

    # ROI table:
    minimal_roi = {
    "0": 0.078,                      # 7.8% for the first candle
    str(timeframe_mins * 10): 0.07,  # 7% after 10 candles (50 minutes)
    str(timeframe_mins * 20): 0.065, # 6.5% after 20 candles (100 minutes)
    str(timeframe_mins * 30): 0.06,  # 6% after 30 candles (150 minutes)
    str(timeframe_mins * 40): 0.062, # 6.2% after 40 candles (200 minutes)
    str(timeframe_mins * 99): 0.039, # 3.9% after 99 candles (495 minutes)
    str(timeframe_mins * 218): 0.0   # Exit after 218 candles (1090 minutes)
    }

    
    stoploss = -0.65

    # Buy hyperspace params:
    buy_params = {
        'low_offset': 0.964, 
        'dema_len_buy': 51
    }

    # Sell hyperspace params:
    sell_params = {
        'high_offset': 1.004, 
        'dema_len_sell': 72
    }

    # Short entry hyperspace params:
    short_entry_params = {
        'short_high_offset': 1.004,
        'short_dema_len_entry': 72
    }

    # Short exit hyperspace params:
    short_exit_params = {
        'short_low_offset': 0.964,
        'short_dema_len_exit': 51,
        'rsi_sell': 70
    }

    low_offset = DecimalParameter(0.80, 1.20, default=1.004, space='buy', optimize=True)
    rsi_buy = IntParameter(30, 70, default=50, space='buy', optimize=True)
    high_offset = DecimalParameter(0.80, 1.20, default=0.964, space='sell', optimize=True)
    dema_len_buy = IntParameter(30, 90, default=72, space='buy', optimize=True)
    dema_len_sell = IntParameter(30, 90, default=51, space='sell', optimize=True)

    short_high_offset = DecimalParameter(0.80, 1.20, default=1.004, space='buy', optimize=True)
    short_low_offset = DecimalParameter(0.80, 1.20, default=0.964, space='sell', optimize=True)
    short_dema_len_entry = IntParameter(30, 90, default=72, space='buy', optimize=True)
    short_dema_len_exit = IntParameter(30, 90, default=51, space='sell', optimize=True)
    rsi_sell = IntParameter(30, 70, default=50, space='sell', optimize=True)

    def informative_pairs(self):
        try:
            pairs = self.dp.current_whitelist()
            informative_pairs = [(pair, self.informative_timeframe) for pair in pairs]
            return informative_pairs
        except Exception as e:
            logger.error(f"Error in informative_pairs: {e}")
            return []

    def slow_tf_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

        displacement = 30
        ichimoku = ftt.ichimoku(dataframe,
                                conversion_line_period=20,
                                base_line_periods=60,
                                laggin_span=120,
                                displacement=displacement
                                )

        dataframe['chikou_span'] = ichimoku['chikou_span']

        # cross indicators
        dataframe['tenkan_sen'] = ichimoku['tenkan_sen']
        dataframe['kijun_sen'] = ichimoku['kijun_sen']

        # cloud, green a > b, red a < b
        dataframe['senkou_a'] = ichimoku['senkou_span_a']
        dataframe['senkou_b'] = ichimoku['senkou_span_b']
        dataframe['leading_senkou_span_a'] = ichimoku['leading_senkou_span_a']
        dataframe['leading_senkou_span_b'] = ichimoku['leading_senkou_span_b']
        dataframe['cloud_green'] = ichimoku['cloud_green'] * 1
        dataframe['cloud_red'] = ichimoku['cloud_red'] * -1

        dataframe.loc[:, 'cloud_top'] = dataframe.loc[:, ['senkou_a', 'senkou_b']].max(axis=1)
        dataframe.loc[:, 'cloud_bottom'] = dataframe.loc[:, ['senkou_a', 'senkou_b']].min(axis=1)

        # DANGER ZONE START

        # NOTE: Not actually the future, present data that is normally shifted forward for display as the cloud
        dataframe['future_green'] = (dataframe['leading_senkou_span_a'] > dataframe['leading_senkou_span_b']).astype(
            'int') * 2
        dataframe['future_red'] = (dataframe['leading_senkou_span_a'] < dataframe['leading_senkou_span_b']).astype(
            'int') * 2

        # The chikou_span is shifted into the past, so we need to be careful not to read the
        # current value.  But if we shift it forward again by displacement it should be safe to use.
        # We're effectively "looking back" at where it normally appears on the chart.
        dataframe['chikou_high'] = (
            (dataframe['chikou_span'] > dataframe['cloud_top'])
        ).shift(displacement).fillna(0).astype('int')

        dataframe['chikou_low'] = (
            (dataframe['chikou_span'] < dataframe['cloud_bottom'])
        ).shift(displacement).fillna(0).astype('int')

        # DANGER ZONE END

        dataframe['atr'] = ta.ATR(dataframe, timeperiod=14)
        ssl_down, ssl_up = ssl_atr(dataframe, 10)
        dataframe['ssl_down'] = ssl_down
        dataframe['ssl_up'] = ssl_up
        dataframe['ssl_ok'] = (
                                  (ssl_up > ssl_down)
                              ).astype('int') * 3
        dataframe['ssl_bear'] = (
                                    (ssl_up < ssl_down)
                                ).astype('int') * 3

        dataframe['ichimoku_ok'] = (
                                           (dataframe['tenkan_sen'] > dataframe['kijun_sen'])
                                           & (dataframe['close'] > dataframe['cloud_top'])
                                           & (dataframe['future_green'] > 0)
                                           & (dataframe['chikou_high'] > 0)
                                   ).astype('int') * 4

        dataframe['ichimoku_bear'] = (
                                             (dataframe['tenkan_sen'] < dataframe['kijun_sen'])
                                             & (dataframe['close'] < dataframe['cloud_bottom'])
                                             & (dataframe['future_red'] > 0)
                                             & (dataframe['chikou_low'] > 0)
                                     ).astype('int') * 4

        dataframe['ichimoku_valid'] = (
                                          (dataframe['leading_senkou_span_b'] == dataframe['leading_senkou_span_b'])
                                      # not NaN
                                      ).astype('int') * 1

        dataframe['trend_pulse'] = (
                                           (dataframe['ichimoku_ok'] > 0)
                                           & (dataframe['ssl_ok'] > 0)
                                   ).astype('int') * 2

        dataframe['bear_trend_pulse'] = (
                                                (dataframe['ichimoku_bear'] > 0)
                                                & (dataframe['ssl_bear'] > 0)
                                        ).astype('int') * 2

        dataframe['trend_over'] = (
                                          (dataframe['ssl_ok'] == 0)
                                          | (dataframe['close'] < dataframe['cloud_top'])
                                  ).astype('int') * 1

        dataframe['bear_trend_over'] = (
                                               (dataframe['ssl_bear'] == 0)
                                               | (dataframe['close'] > dataframe['cloud_bottom'])
                                       ).astype('int') * 1

        dataframe.loc[(dataframe['trend_pulse'] > 0), 'trending'] = 3
        dataframe.loc[(dataframe['trend_over'] > 0), 'trending'] = 0
        dataframe['trending'] = dataframe['trending'].ffill()

        dataframe.loc[(dataframe['bear_trend_pulse'] > 0), 'bear_trending'] = 3
        dataframe.loc[(dataframe['bear_trend_over'] > 0), 'bear_trending'] = 0
        dataframe['bear_trending'] = dataframe['bear_trending'].ffill()

        # RSI
        dataframe['rsi'] = ta.RSI(dataframe, timeperiod=14)

        return dataframe

    def fast_tf_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        if self.config['runmode'].value == 'hyperopt':
            for len in range(30, 91):
                dataframe[f'dema_{len}'] = ftt.dema(dataframe, period=len)
        else:
            dataframe[f'dema_{self.dema_len_buy.value}'] = ftt.dema(dataframe, period=self.dema_len_buy.value)
            dataframe[f'dema_{self.dema_len_sell.value}'] = ftt.dema(dataframe, period=self.dema_len_sell.value)
            dataframe[f'dema_{self.short_dema_len_entry.value}'] = ftt.dema(dataframe, period=self.short_dema_len_entry.value)
            dataframe[f'dema_{self.short_dema_len_exit.value}'] = ftt.dema(dataframe, period=self.short_dema_len_exit.value)
            
            dataframe[f'dema_buy'] = ftt.dema(dataframe, period=self.dema_len_buy.value) * self.low_offset.value
            dataframe[f'dema_sell'] = ftt.dema(dataframe, period=self.dema_len_sell.value) * self.high_offset.value
            dataframe[f'dema_short_entry'] = ftt.dema(dataframe, period=self.short_dema_len_entry.value) * self.short_high_offset.value
            dataframe[f'dema_short_exit'] = ftt.dema(dataframe, period=self.short_dema_len_exit.value) * self.short_low_offset.value

        return dataframe

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:

        assert (timeframe_to_minutes(self.timeframe) == 5), "Run this strategy at 5m."
        if self.timeframe == self.informative_timeframe:
            dataframe = self.slow_tf_indicators(dataframe, metadata)
        else:
            assert self.dp, "DataProvider is required for multiple timeframes."
            informative = self.dp.get_pair_dataframe(pair=metadata['pair'], timeframe=self.informative_timeframe)
            informative = self.slow_tf_indicators(informative.copy(), metadata)
            dataframe = merge_informative_pair(dataframe, informative, self.timeframe, self.informative_timeframe, ffill=True)
            # don't overwrite the base dataframe's OHLCV information
            skip_columns = [(s + "_" + self.informative_timeframe) for s in ['date', 'open', 'high', 'low', 'close', 'volume']]
            dataframe.rename(columns=lambda s: s.replace("_{}".format(self.informative_timeframe), "") if (not s in skip_columns) else s, inplace=True)
        dataframe = self.fast_tf_indicators(dataframe, metadata)

        return dataframe

    def leverage(self, pair: str, current_time: 'datetime', current_rate: float, proposed_leverage: float, max_leverage: float, **kwargs) -> float:
        return 10

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dema_long = f'dema_{self.dema_len_buy.value}'
        dema_short = f'dema_{self.short_dema_len_entry.value}'
        
        dataframe.loc[
            (dataframe['ichimoku_valid'] > 0)
            & (dataframe['bear_trending'] == 0)
            & (dataframe['rsi'] < self.rsi_buy.value)
            & (dataframe['close'] < (dataframe[dema_long] * self.low_offset.value))
            , 'enter_long'] = 1
        
        dataframe.loc[
            (dataframe['ichimoku_valid'] > 0)
            & (dataframe['trending'] == 0)
            & (dataframe['rsi'] > self.rsi_sell.value)
            & (dataframe['close'] > (dataframe[dema_short] * self.short_high_offset.value))
            , 'enter_short'] = 1
        
        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        dema_long = f'dema_{self.dema_len_sell.value}'
        dema_short = f'dema_{self.short_dema_len_exit.value}'
        
        dataframe.loc[
            (dataframe['close'] > (dataframe[dema_long] * self.high_offset.value))
            | (dataframe['rsi'] > 70)
            , 'exit_long'] = 1
        
        dataframe.loc[
            (dataframe['close'] < (dataframe[dema_short] * self.short_low_offset.value))
            | (dataframe['rsi'] < 30)
            , 'exit_short'] = 1
        
        return dataframe
    
    def adjust_trade_position(self, trade: Trade, current_time: datetime,
                            current_rate: float, current_profit: float,
                            min_stake: Optional[float], max_stake: float,
                            current_entry_rate: float, current_exit_rate: float,
                            current_entry_profit: float, current_exit_profit: float,
                            **kwargs
                            ) -> Union[Optional[float], Tuple[Optional[float], Optional[str]]]:
        """
        Adjust trade position when current profit reaches -10% by averaging down or up.
        Positive values returned increase position, negative values decrease it.
        """
        if not trade.is_open:
            return None

        count_of_adjustments = 0
        if hasattr(trade, 'adjustments') and trade.adjustments:
            count_of_adjustments = len(trade.adjustments)

        if count_of_adjustments >= self.max_adjustments:
            return None
        # Define the profit threshold for making an adjustment
        profit_threshold = -0.10  # 10% negative profit

        # Check if the current profit has reached the threshold for adjustment
        if current_profit < profit_threshold:
            try:
                # Current stake amount based on the original trade
                current_stake_amount = trade.stake_amount
                # The amount to add - you might decide on different logic for the amount to add
                additional_stake = current_stake_amount  # Doubling down

                # Ensure the additional stake does not exceed the maximum allowed stake
                if additional_stake + current_stake_amount > max_stake:
                    additional_stake = max_stake - current_stake_amount

                # If the min_stake is not None and additional stake is less than min_stake, increase to min_stake if possible
                if min_stake is not None and additional_stake < min_stake:
                    if min_stake <= max_stake:
                        additional_stake = min(min_stake, max_stake - current_stake_amount)
                    else:
                        return None, f"Cannot adjust: minimum stake of ${min_stake} exceeds maximum stake of ${max_stake}."
                logger.info(f"Adjusting position for trade {trade.id}: adding {additional_stake} to stake.")
                return additional_stake, 'adjust_negative_10%'
            except Exception as e:
                logger.error(f"Failed to calculate additional stake: {str(e)}")
                return None, "Error in calculating additional stake."

        return None

    
    plot_config = {
        # Main plot indicators (Moving averages, ...)
        'main_plot': {
            'senkou_a': {
                'color': 'green',
                'fill_to': 'senkou_b',
                'fill_label': 'Ichimoku Cloud',
                'fill_color': 'rgba(0,0,0,0.2)',
            },
            # plot senkou_b, too. Not only the area to it.
            'senkou_b': {
                'color': 'red',
            },
            'tenkan_sen': { 'color': 'blue' },
            'kijun_sen': { 'color': 'orange' },

            # 'chikou_span': { 'color': 'lightgreen' },

            'ssl_up': { 'color': 'green' },
            # 'ssl_down': { 'color': 'red' },

            # 'ema50': { 'color': 'violet' },
            # 'ema200': { 'color': 'magenta' },

            'zema_buy': { 'color': 'blue' },
            'zema_sell': { 'color': 'orange' },
        },
        'subplots': {
            "Trend": {
                'trending': {'color': 'green'},
                'bear_trending': {'color': 'red'},
            },
            "Bull": {
                'trend_pulse': {'color': 'blue'},
                'trending': {'color': 'orange'},
                'trend_over': {'color': 'red'},
            },
            "Bull Signals": {
                'ichimoku_ok': {'color': 'green'},
                'ssl_ok': {'color': 'red'},
            },
            "Bear": {
                'bear_trend_pulse': {'color': 'blue'},
                'bear_trending': {'color': 'orange'},
                'bear_trend_over': {'color': 'red'},
            },
            "Bear Signals": {
                'ichimoku_bear': {'color': 'green'},
                'ssl_bear': {'color': 'red'},
            },
            "Misc": {
                'ichimoku_valid': {'color': 'green'},
            },
        }
    }
